import axios, { AxiosInstance } from 'axios';
import { logger } from '@/config/logger';
import { config } from '@/config';

export interface CJProduct {
  id: string;
  title: string;
  description: string;
  price: number;
  currency: string;
  images: string[];
  category: string;
  vendor: string;
  shippingInfo: {
    isShippable: boolean;
    shippingCost: number;
    etaMinDays: number;
    etaMaxDays: number;
    methodName: string;
  }[];
}

export interface CJSearchParams {
  keyword?: string;
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  page?: number;
  limit?: number;
}

export interface CJShippingInfo {
  destinationCountry: string;
  isShippable: boolean;
  shippingCost: number;
  etaMinDays: number;
  etaMaxDays: number;
  methodName: string;
}

export class CJDropshippingService {
  private client: AxiosInstance;
  private accessToken: string | null = null;
  private refreshToken: string | null = null;
  private tokenExpiry: number | null = null;

  constructor() {
    this.client = axios.create({
      baseURL: 'https://developers.cjdropshipping.com/api2.0/v1',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
    this.initializeAuth();
  }

  private async initializeAuth() {
    try {
      await this.authenticate();
    } catch (error) {
      logger.error('Failed to initialize CJ Dropshipping authentication:', error);
    }
  }

  private async authenticate(): Promise<void> {
    try {
      const response = await this.client.post('/authentication/getAccessToken', {
        email: config.cjDropshipping.email,
        apiKey: config.cjDropshipping.password, // Using password as apiKey
      });

      if (response.status === 200 && response.data && response.data.result === true) {
        this.accessToken = response.data.data.accessToken;
        this.refreshToken = response.data.data.refreshToken;
        this.tokenExpiry = new Date(response.data.data.accessTokenExpiryDate).getTime();
        
        this.updateAuthHeaders();
        logger.info('CJ Dropshipping authentication successful', {
          accessToken: this.accessToken?.substring(0, 10) + '...',
          expiryDate: response.data.data.accessTokenExpiryDate,
        });
      } else {
        throw new Error(`Authentication failed: ${response.data.message || 'Unknown error'}`);
      }
    } catch (error: any) {
      // Handle rate limiting
      if (error.response?.status === 429) {
        logger.warn('CJ Dropshipping authentication rate limited, will retry later', {
          message: error.response.data.message,
          retryAfter: '5 minutes',
        });
        // Set a flag to retry later
        this.tokenExpiry = Date.now() + (5 * 60 * 1000); // 5 minutes from now
        throw new Error('Rate limited: Please try again in 5 minutes');
      }
      
      logger.error('CJ Dropshipping authentication failed:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      throw error;
    }
  }

  private updateAuthHeaders() {
    if (this.accessToken) {
      this.client.defaults.headers.common['CJ-Access-Token'] = this.accessToken;
    }
  }

  private async ensureValidToken(): Promise<void> {
    if (!this.accessToken || (this.tokenExpiry && Date.now() >= this.tokenExpiry)) {
      await this.authenticate();
    }
  }

  private setupInterceptors() {
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;
        
        // Handle 401 errors (token expired)
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          
          try {
            await this.refreshAccessToken();
            originalRequest.headers['Authorization'] = `Bearer ${this.accessToken}`;
            return this.client(originalRequest);
          } catch (refreshError) {
            logger.error('Failed to refresh CJ Dropshipping token:', refreshError);
            return Promise.reject(error);
          }
        }
        
        logger.error('CJ Dropshipping API error:', {
          status: error.response?.status,
          message: error.response?.data?.message || error.message,
          url: error.config?.url,
          data: error.response?.data,
        });
        return Promise.reject(error);
      }
    );
  }

  private async refreshAccessToken(): Promise<void> {
    try {
      if (this.refreshToken) {
        const response = await this.client.post('/authentication/refreshAccessToken', {
          refreshToken: this.refreshToken,
        });

        if (response.status === 200 && response.data && response.data.result === true) {
          this.accessToken = response.data.data.accessToken;
          this.refreshToken = response.data.data.refreshToken;
          this.tokenExpiry = new Date(response.data.data.accessTokenExpiryDate).getTime();
          this.updateAuthHeaders();
          logger.info('CJ Dropshipping token refreshed successfully');
        } else {
          throw new Error('Invalid refresh response');
        }
      } else {
        // If no refresh token, re-authenticate
        await this.authenticate();
      }
    } catch (error: any) {
      logger.error('Failed to refresh CJ Dropshipping token:', error);
      // Fallback to full authentication
      await this.authenticate();
    }
  }

  /**
   * Search for products
   */
  async searchProducts(params: CJSearchParams): Promise<CJProduct[]> {
    try {
      await this.ensureValidToken();
      
      const response = await this.client.get('/product/list', {
        params: {
          productName: params.keyword,
          categoryId: params.category,
          minPrice: params.minPrice,
          maxPrice: params.maxPrice,
          pageNum: params.page || 1,
          pageSize: params.limit || 50,
        },
      });

      // Check if response is successful based on documentation
      if (response.status !== 200 || (response.data.code && response.data.code !== 200)) {
        throw new Error(`API request failed: ${response.data.message || 'Unknown error'}`);
      }

      // Transform the response to match our expected format
      const products = response.data.data?.list || [];
      return products.map((product: any) => ({
        id: product.pid,
        sourceProductId: product.pid,
        title: product.productNameEn || product.productName,
        description: product.productName,
        price: product.sellPrice,
        currency: 'USD', // Default currency
        vendorName: product.supplierName,
        images: product.productImage ? [product.productImage] : [],
        categoryPath: product.categoryName ? [product.categoryName] : [],
        variants: product.variants || [],
        weight: product.productWeight,
        sku: product.productSku,
        listedNum: product.listedNum,
        supplierId: product.supplierId,
        productType: product.productType,
        customizationVersion: product.customizationVersion,
      }));

    } catch (error: any) {
      logger.error('Failed to search products from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      throw new Error('Failed to search products from CJ Dropshipping');
    }
  }

  /**
   * Get product details by ID
   */
  async getProductDetails(productId: string): Promise<CJProduct | null> {
    try {
      await this.ensureValidToken();
      
      const response = await this.client.get('/product/info', {
        params: {
          pid: productId,
        },
      });
      
      // Check if response is successful based on documentation
      if (response.status !== 200 || (response.data.code && response.data.code !== 200)) {
        throw new Error(`API request failed: ${response.data.message || 'Unknown error'}`);
      }

      const product = response.data.data;
      if (!product) return null;

      return {
        id: product.productId,
        title: product.productName,
        description: product.productDescription || '',
        price: parseFloat(product.price),
        currency: product.currency || 'USD',
        images: product.images || [],
        category: product.categoryName || '',
        vendor: product.supplierName || 'CJ Dropshipping',
        shippingInfo: [], // Will be populated separately
      };

    } catch (error: any) {
      logger.error('Failed to get product details from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      throw new Error('Failed to get product details from CJ Dropshipping');
    }
  }

  /**
   * Get shipping information for a product
   */
  async getShippingInfo(productId: string, destinationCountry: string): Promise<CJShippingInfo[]> {
    try {
      await this.ensureValidToken();
      
      const response = await this.client.get(`/product/shipping/${productId}`, {
        params: {
          country: destinationCountry,
        },
      });

      // Check if response is successful based on documentation
      if (response.status !== 200 || (response.data.code && response.data.code !== 200)) {
        throw new Error(`API request failed: ${response.data.message || 'Unknown error'}`);
      }

      const shippingOptions = response.data.data?.shippingOptions || [];
      
      return shippingOptions.map((option: any) => ({
        destinationCountry,
        isShippable: option.isShippable || false,
        shippingCost: parseFloat(option.shippingCost || 0),
        etaMinDays: parseInt(option.etaMinDays || 0),
        etaMaxDays: parseInt(option.etaMaxDays || 0),
        methodName: option.methodName || 'Standard Shipping',
      }));

    } catch (error: any) {
      logger.error('Failed to get shipping info from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      return [{
        destinationCountry,
        isShippable: false,
        shippingCost: 0,
        etaMinDays: 0,
        etaMaxDays: 0,
        methodName: 'Unknown',
      }];
    }
  }

  /**
   * Get product categories
   */
  async getCategories(): Promise<Array<{ id: string; name: string; parentId?: string }>> {
    try {
      await this.ensureValidToken();
      
      const response = await this.client.get('/product/categories');
      
      // Check if response is successful based on documentation
      if (response.status !== 200 || (response.data.code && response.data.code !== 200)) {
        throw new Error(`API request failed: ${response.data.message || 'Unknown error'}`);
      }

      const categories = response.data.data || [];
      return categories.map((category: any) => ({
        id: category.categoryId,
        name: category.categoryName,
        parentId: category.parentCategoryId,
      }));

    } catch (error: any) {
      logger.error('Failed to get categories from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      return [];
    }
  }

  /**
   * Check if the service is healthy
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.ensureValidToken();
      const response = await this.client.get('/product/categories');
      return response.status === 200 && (!response.data.code || response.data.code === 200);
    } catch (error: any) {
      logger.error('CJ Dropshipping API health check failed:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      return false;
    }
  }

  /**
   * Debug method to test authentication and API connection
   */
  async debugAuth(): Promise<any> {
    const results = {
      config: {
        hasEmail: !!config.cjDropshipping.email,
        hasPassword: !!config.cjDropshipping.password,
        baseUrl: config.cjDropshipping.baseUrl,
        rateLimit: config.cjDropshipping.rateLimit,
      },
      auth: {
        hasAccessToken: !!this.accessToken,
        hasRefreshToken: !!this.refreshToken,
        tokenExpiry: this.tokenExpiry,
        isTokenExpired: this.tokenExpiry ? Date.now() >= this.tokenExpiry : null,
      },
      testResults: {} as Record<string, any>,
    };

    // Test authentication
    try {
      await this.authenticate();
      results.testResults.authentication = {
        success: true,
        message: 'Authentication successful',
        accessToken: this.accessToken ? 'Present' : 'Missing',
        refreshToken: this.refreshToken ? 'Present' : 'Missing',
      };
    } catch (error: any) {
      results.testResults.authentication = {
        success: false,
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      };
    }

    // Test API endpoints
    const endpoints = [
      { name: 'categories', url: '/product/categories' },
      { name: 'search', url: '/product/search', params: { keyword: 'test', limit: 1 } },
    ];

    for (const endpoint of endpoints) {
      try {
        await this.ensureValidToken();
        const response = await this.client.get(endpoint.url, { params: endpoint.params });
        results.testResults[endpoint.name] = {
          success: true,
          status: response.status,
          dataKeys: Object.keys(response.data || {}),
        };
      } catch (error: any) {
        results.testResults[endpoint.name] = {
          success: false,
          status: error.response?.status,
          message: error.response?.data?.message || error.message,
          data: error.response?.data,
        };
      }
    }

    return results;
  }

  /**
   * Import products in bulk
   */
  async importProducts(productIds: string[], destinationCountry: string = 'US'): Promise<CJProduct[]> {
    try {
      await this.ensureValidToken();
      
      const products: CJProduct[] = [];
      
      // Process products in batches to avoid rate limiting
      const batchSize = 10;
      for (let i = 0; i < productIds.length; i += batchSize) {
        const batch = productIds.slice(i, i + batchSize);
        
        const batchPromises = batch.map(async (productId) => {
          try {
            const product = await this.getProductDetails(productId);
            if (product) {
              // Get shipping information
              const shippingInfo = await this.getShippingInfo(productId, destinationCountry);
              return {
                ...product,
                shippingInfo,
              };
            }
            return null;
          } catch (error) {
            logger.error(`Failed to import product ${productId}:`, error);
            return null;
          }
        });
        
        const batchResults = await Promise.all(batchPromises);
        products.push(...batchResults.filter(p => p !== null));
        
        // Add delay between batches to respect rate limits
        if (i + batchSize < productIds.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      
      logger.info(`Successfully imported ${products.length} products from CJ Dropshipping`);
      return products;
      
    } catch (error: any) {
      logger.error('Failed to import products from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      throw new Error('Failed to import products from CJ Dropshipping');
    }
  }

  /**
   * Search and import products by keyword
   */
  async searchAndImportProducts(
    keyword: string, 
    limit: number = 50, 
    destinationCountry: string = 'US'
  ): Promise<CJProduct[]> {
    try {
      // First search for products
      const searchResults = await this.searchProducts({
        keyword,
        limit,
      });
      
      if (searchResults.length === 0) {
        logger.info(`No products found for keyword: ${keyword}`);
        return [];
      }
      
      // Extract product IDs
      const productIds = searchResults.map(p => p.id);
      
      // Import the products with full details
      return await this.importProducts(productIds, destinationCountry);
      
    } catch (error: any) {
      logger.error('Failed to search and import products from CJ Dropshipping:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
      });
      throw new Error('Failed to search and import products from CJ Dropshipping');
    }
  }
}

export const cjDropshippingService = new CJDropshippingService();
